import pathlib as path
import json
import itk
import pickle
import shutil

from abc import ABC, abstractmethod

from tbitk.util import extract_slice

class InferenceResult(ABC):
    '''
    Abstract class encapsulating result from running the model inference on
    some input.
    '''
    OBJECT_FNAME = path.Path("inference_result.p")
    JSON_FNAME = path.Path("inference_result_simple.json")

    def __init__(self, source, mask, onsd):
        '''
        Attributes
        ----------
        source : itk.Image[itk.F,] or list of itk.Image[itk.F, 2]
            Input image / video to the model
        mask : itk.Image[itk.UC,] or list of itk.Image[itk.UC, 2]
            The predicted mask generated by the model
        onsd : float
            The predicted final onsd for the input
        '''
        self.source = source
        self.mask = mask
        self.onsd = onsd

    def _save_pickleable_portion(self, outpath):
        """
        Saves the pickleable (everything except itk images) portion of the
        object out to a file.

        Parameters
        ----------
        outpath : pathlib.Path
            Path to save the pickleable portion of the object to

        Returns
        ----------
        None
        """
        temp_source = self.source
        temp_mask = self.mask

        self.source = None
        self.mask = None

        with open(str(outpath / self.OBJECT_FNAME), 'wb') as f:
            pickle.dump(self, f)

        self.source = temp_source
        self.mask = temp_mask

    @abstractmethod
    def _save_unpickleable_portion(self, outpath):
        """
        Saves the unpickleable part of the object (like itk images)
        out to a file. Implemented by subclasses.

        Parameters
        ----------
        outpath : pathlib.Path
            Path to save the unpickleable portion of the object to

        Returns
        ----------
        None
        """
        pass

    def save_to_dir(self, outpath):
        '''
        Save this InferenceResult object to a directory. Overwrites the
        directory if it already exists.

        Parameters
        ----------
        outpath : pathlib.Path or str
            The directory to save to

        Returns
        -------
        None
        '''
        if isinstance(outpath, str):
            outpath = path.Path(outpath)

        if "." in str(outpath.name):
            raise ValueError(f"outpath must be a directory name. Got {outpath}")

        if outpath.exists():
            shutil.rmtree(outpath)

        outpath.mkdir(parents=True, exist_ok=False)

        self._save_pickleable_portion(outpath)
        self._save_unpickleable_portion(outpath)

        # Also write out a JSON representation for easy access
        self._save_calculations_to_json(outpath / self.JSON_FNAME)

    @classmethod
    # TODO: return ans inside the context manager?
    def _load_pickleable_portion(cls, inpath):
        """
        Loads the pickleable (everything except itk images) portion of
        the object from a directory.

        Parameters
        ----------
        inpath : pathlib.Path
            Path to load the pickleable portion of the object from

        Returns
        ----------
        InferenceResult
        """
        with open(str(inpath / cls.OBJECT_FNAME), "rb") as f:
            ans = pickle.load(f)

        return ans

    @abstractmethod
    def _load_unpickleable_portion(self, inpath):
        """
        Loads the unpickleable (itk images) portion of
        the object from a file.

        Parameters
        ----------
        inpath : pathlib.Path
            Path to load the pickleable portion of the object from

        Returns
        ----------
        None
        """
        pass

    @classmethod
    def load_from_dir(cls, inpath):
        """
        Loads an inference result object from disk.

        Parameters
        ----------
        inpath : pathlib.Path or str
            Path to load the object from

        Returns
        ----------
        InferenceResult
        """
        if isinstance(inpath, str):
            inpath = path.Path(inpath)

        ans = cls._load_pickleable_portion(inpath)
        ans._load_unpickleable_portion(inpath)

        return ans

    @abstractmethod
    def _save_calculations_to_json(self, outpath):
        """
        Saves the JSON representation of the object to disk.

        Parameters
        ----------
        outpath : pathlib.Path or str
            Path to save the JSON representation to

        Returns
        ----------
        None
        """
        pass


class InferenceResult2D(InferenceResult):
    '''
    Class encapsulating result from running the model inference on
    some 2d image
    '''
    SOURCE_FNAME = path.Path("source.mha")
    MASK_FNAME = path.Path("mask.mha")

    def __init__(self, source, mask, onsd=None, score=None):
        '''
        Attributes
        ----------
        source : itk.Image[itk.F, 2]
            Input image / video to the model
        mask : itk.Image[itk.UC, 2]
            The predicted mask generated by the model
        onsd : float, optional
            The predicted final onsd for the input
        score : float, optional
            median gradient magnitude at the nerve boundary
        '''
        super().__init__(source, mask, onsd)
        # TODO: Check if these are 2d
        self.score = score

    def _save_calculations_to_json(self, outpath):
        res = dict()
        res["score"] = self.score
        res["onsd"] = self.onsd

        # Now save
        with open(str(outpath), "w") as outfile:
            json.dump(res, outfile)


    def _save_unpickleable_portion(self, outpath):
        itk.imwrite(self.source, str(outpath / self.SOURCE_FNAME), compression=True)
        itk.imwrite(self.mask, str(outpath / self.MASK_FNAME), compression=True)


    def _load_unpickleable_portion(self, inpath):
        self.source = itk.imread(str(inpath / self.SOURCE_FNAME))
        self.mask = itk.imread(str(inpath / self.MASK_FNAME))



class InferenceResult3D(InferenceResult):
    '''
    Abstract class encapsulating result from running the model inference on
    some video / 3D image
    '''
    def __init__(
        self,
        source,
        mask,
        onsd=None,
        onsd_history=dict(),
        score_history=dict(),
    ):
        '''
        Attributes
        ----------
        source : itk.Image[itk.F, 3] or list of itk.Image[itk.F, 2]
            Input image / video to the model
        mask : itk.Image[itk.UC, 3] or list of itk.Image[itk.UC, 2]
            The predicted mask generated by the model
        onsd : float, optional
            The predicted final onsd for the input
        onsd_history : dict, optional
            predicted onsd per frame
        score_history : dict, optional
            median gradient magnitude at the nerve boundary per frame
        '''
        # TODO: Check if these are 3d
        super().__init__(source, mask, onsd)
        self.onsd_history = onsd_history
        self.score_history = score_history


    def __getitem__(self, frame_num):
        """
        Returns the 2d inference result corresponding to the frame.

        Parameters
        ----------
        frame_num : int
            Frame number to index.

        Returns
        ----------
        InferenceResult2D
        """
        source_frame = self._get_source_frame(frame_num)
        mask_frame = self._get_mask_frame(frame_num)
        onsd = self.onsd_history[frame_num] if frame_num in self.onsd_history else None
        score = (
            self.score_history[frame_num] if frame_num in self.score_history else None
        )
        return InferenceResult2D(
            source_frame, mask_frame, onsd, score
        )

    @abstractmethod
    def __len__(self):
        """
        Get the length of the inference result object. This corresponds to
        the number of frames that the inference was run on / the number of
        frames in the source video.

        Returns
        ----------
        int
        """
        pass

    @abstractmethod
    def _get_source_frame(self, frame_num):
        """
        Retrieve one frame of the source video.

        Parameters
        ----------
        frame_num : int
            The frame number to use as an index

        Returns
        ----------
        itk.Image[itk.F, 2]
        """
        pass

    @abstractmethod
    def _get_mask_frame(self, frame_num):
        """
        Retrieve one frame of the mask video.

        Parameters
        ----------
        frame_num : int
            The frame number to use as an index

        Returns
        ----------
        itk.Image[itk.UC, 2]
        """
        pass

    def _save_calculations_to_json(self, outpath):
        res = dict()
        res["onsd_history"] = self.onsd_history
        res["score_history"] = self.score_history
        res["final_onsd"] = self.onsd

        # Now save
        with open(str(outpath), "w") as outfile:
            json.dump(res, outfile)


class InferenceResult3DMultiSource(InferenceResult3D):
    '''
    Class encapsulating result from running the model inference on
    several 3D input sources concatenated into one. For example, an ultrasound
    video acquired with a butterfly probe and another with a clarius probe,
    both with the same subject. These two videos could be combined before
    running the model inference, and the model sees the combined video as
    one source.
    '''
    SOURCE_FRAMES_SUBDIR = path.Path("source_frames")
    MASK_FRAMES_SUBDIR = path.Path("mask_frames")

    def __init__(
        self,
        source,
        mask,
        onsd=None,
        onsd_history=dict(),
        score_history=dict(),
    ):
        '''
        Attributes
        ----------
        source : list of itk.Image[itk.F, 2]
            Input image / video to the model
        mask : list of itk.Image[itk.UC, 2]
            The predicted mask generated by the model
        onsd : float, optional
            The predicted final onsd for the input
        onsd_history : dict, optional
            predicted onsd per frame
        score_history : dict, optional
            median gradient magnitude at the nerve boundary per frame
        '''
        if not isinstance(source, list):
            raise ValueError("Must pass list of itk images as source")

        if not isinstance(mask, list):
            raise ValueError("Must pass list of itk images as mask")

        super().__init__(source, mask, onsd, onsd_history, score_history)
        self._length = len(self.source)


    def __len__(self):
        return self._length

    def _get_source_frame(self, frame_num):
        return self.source[frame_num]

    def _get_mask_frame(self, frame_num):
        return self.mask[frame_num]

    def _save_unpickleable_portion(self, outpath):
        source_frame_path_stem = outpath / self.SOURCE_FRAMES_SUBDIR
        mask_frame_path_stem = outpath / self.MASK_FRAMES_SUBDIR

        source_frame_path_stem.mkdir(parents=True, exist_ok=False)
        mask_frame_path_stem.mkdir(parents=True, exist_ok=False)

        for i, (source_frame, mask_frame) in enumerate(zip(self.source, self.mask)):
            next_source_frame_path = str(source_frame_path_stem / f"{i}.mha")
            next_mask_frame_path = str(mask_frame_path_stem / f"{i}.mha")

            itk.imwrite(source_frame, next_source_frame_path, compression=True)
            itk.imwrite(mask_frame, next_mask_frame_path, compression=True)

    def _load_unpickleable_portion(self, inpath):
        """
        Loads the unpickleable (itk images) portion of
        the object from a file. Assumes self._length is defined

        Parameters
        ----------
        inpath : pathlib.Path
            Path to load the pickleable portion of the object from

        Returns
        ----------
        None
        """
        self.source = []
        self.mask = []

        source_frame_path_stem = inpath / self.SOURCE_FRAMES_SUBDIR
        mask_frame_path_stem = inpath / self.MASK_FRAMES_SUBDIR

        # Assumes len(self) is well defined at this point.
        # It should be if _load_pickleable portion is called first
        for i in range(len(self)):
            next_source_frame_path = str(source_frame_path_stem / f"{i}.mha")
            next_mask_frame_path = str(mask_frame_path_stem / f"{i}.mha")

            self.source.append(itk.imread(next_source_frame_path))
            self.mask.append(itk.imread(next_mask_frame_path))


class InferenceResult3DSingleSource(InferenceResult3D):
    '''
    Class encapsulating result from running the model inference on
    one 3D input source.
    '''
    SOURCE_FNAME = path.Path("source.mha")
    MASK_FNAME = path.Path("mask.mha")

    def __init__(
        self,
        source,
        mask,
        onsd=None,
        onsd_history=dict(),
        score_history=dict(),
    ):
        '''
        Attributes
        ----------
        source : itk.Image[itk.F, 3]
            Input image / video to the model
        mask : itk.Image[itk.UC, 3]
            The predicted mask generated by the model
        onsd : float, optional
            The predicted final onsd for the input
        onsd_history : dict, optional
            Predicted onsd per frame
        score_history : dict, optional
            Median gradient magnitude at the nerve boundary per frame
        '''
        super().__init__(source, mask, onsd, onsd_history, score_history)
        self._length = self.source.GetLargestPossibleRegion().GetSize()[2]

    def __len__(self):
        return self._length

    def _get_source_frame(self, frame_num):
        return extract_slice(self.source, frame_num)

    def _get_mask_frame(self, frame_num):
        return extract_slice(self.mask, frame_num)

    def _save_unpickleable_portion(self, outpath):
        itk.imwrite(self.source, str(outpath / self.SOURCE_FNAME), compression=True)
        itk.imwrite(self.mask, str(outpath / self.MASK_FNAME), compression=True)

    def _load_unpickleable_portion(self, inpath):
        self.source = itk.imread(str(inpath / self.SOURCE_FNAME))
        self.mask = itk.imread(str(inpath / self.MASK_FNAME))
